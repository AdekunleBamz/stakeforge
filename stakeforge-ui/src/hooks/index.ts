export { useWallet } from './useWallet';
export { useStaking } from './useStaking';































































































}  return { isHovered, hoverProps };  };    onMouseLeave: useCallback(() => setIsHovered(false), [])    onMouseEnter: useCallback(() => setIsHovered(true), []),  const hoverProps = {  const [isHovered, setIsHovered] = useState(false);} {  };    onMouseLeave: () => void;    onMouseEnter: () => void;  hoverProps: {  isHovered: boolean;export function useHoverProps(): { */ * Alternative to using a ref * A hook that returns hover props to spread on an element/**}  return [ref, isHovered];  }, [delay]);    };      element.removeEventListener('mouseleave', handleMouseLeave);      element.removeEventListener('mouseenter', handleMouseEnter);      }        clearTimeout(timeoutRef.current);      if (timeoutRef.current) {    return () => {    element.addEventListener('mouseleave', handleMouseLeave);    element.addEventListener('mouseenter', handleMouseEnter);    };      setIsHovered(false);      }        clearTimeout(timeoutRef.current);      if (timeoutRef.current) {    const handleMouseLeave = () => {    };      }, delay);        setIsHovered(true);      timeoutRef.current = setTimeout(() => {    const handleMouseEnter = () => {    if (!element) return;    const element = ref.current;  useEffect(() => {  const timeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);  const ref = useRef<T>(null);  const [isHovered, setIsHovered] = useState(false);): [RefObject<T>, boolean] {  delay: number = 200export function useDelayedHover<T extends HTMLElement = HTMLElement>( */ * @param delay Delay in ms before hover is considered active * Useful for tooltips and hover cards * A hook that tracks hover with a delay before triggering/**}  return [ref, isHovered];  }, []);    };      element.removeEventListener('mouseleave', handleMouseLeave);      element.removeEventListener('mouseenter', handleMouseEnter);    return () => {    element.addEventListener('mouseleave', handleMouseLeave);    element.addEventListener('mouseenter', handleMouseEnter);    const handleMouseLeave = () => setIsHovered(false);    const handleMouseEnter = () => setIsHovered(true);    if (!element) return;    const element = ref.current;  useEffect(() => {  const ref = useRef<T>(null);  const [isHovered, setIsHovered] = useState(false);] {  boolean  RefObject<T>,export function useHover<T extends HTMLElement = HTMLElement>(): [ */ * @returns A ref to attach to the element and the hover state * A hook that tracks whether an element is being hovered/**export { useDebounce, useDebouncedCallback } from './useDebounce';
export { useMediaQuery, useIsMobile, useIsTablet, useIsDesktop, usePrefersDarkMode, usePrefersReducedMotion } from './useMediaQuery';
export { useClickOutside, useClickOutsideMultiple } from './useClickOutside';
export { useCopyToClipboard, useCopy } from './useCopyToClipboard';
export { useCountdown, useTimer } from './useCountdown';
export { useScrollLock, useScrollLockControl } from './useScrollLock';
